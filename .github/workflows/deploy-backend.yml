name: Deploy Backend

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: sa-east-1

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REPOSITORY_URI: ${{ vars.ECR_REPOSITORY_URI }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Current directory: $(pwd)"
          echo "Checking for Dockerfile..."
          if [ ! -f "Dockerfile" ]; then
            echo "❌ Dockerfile no encontrado. Creando Dockerfile runtime simple y construyendo JAR con Gradle..."
            ./gradlew clean shadowJar -x test
            echo 'FROM eclipse-temurin:17-jre-alpine' > Dockerfile
            echo 'WORKDIR /app' >> Dockerfile
            echo 'RUN addgroup -S appgroup && adduser -S appuser -G appgroup' >> Dockerfile
            echo 'COPY build/libs/*all.jar app.jar' >> Dockerfile
            echo 'RUN mkdir -p /app/config /app/logs && chown -R appuser:appgroup /app' >> Dockerfile
            echo 'USER appuser' >> Dockerfile
            echo 'EXPOSE 8080' >> Dockerfile
            echo 'ENV JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseG1GC -XX:MaxGCPauseMillis=200"' >> Dockerfile
            echo 'ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -Dconfig.file=/app/config/application.conf -jar app.jar"]' >> Dockerfile
          fi
          
          echo "Building Docker image..."
          docker build -t ${ECR_REPOSITORY_URI}:${IMAGE_TAG} .
          docker tag ${ECR_REPOSITORY_URI}:${IMAGE_TAG} ${ECR_REPOSITORY_URI}:latest
          
          echo "Pushing Docker image to ECR..."
          docker push ${ECR_REPOSITORY_URI}:${IMAGE_TAG}
          docker push ${ECR_REPOSITORY_URI}:latest

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    environment: prod
    steps:
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.SSH_HOST }}
          username: ${{ vars.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ vars.SSH_PORT || 22 }}
          script: |
            set -e
            
            # Asegurar Docker activo
            sudo systemctl start docker || true
            
            # Variables docker
            DOCKER_CMD="docker"
            if ! docker info >/dev/null 2>&1; then DOCKER_CMD="sudo docker"; fi
            
            # Login a ECR
            aws ecr get-login-password --region ${{ vars.AWS_REGION || 'sa-east-1' }} | $DOCKER_CMD login --username AWS --password-stdin ${{ vars.ECR_REPOSITORY_URI }}
            
            # Crear docker-compose de producción
            sudo bash -c 'printf "services:\n  backend:\n    image: \${ECR_IMAGE}\n    container_name: cadetex-backend\n    restart: unless-stopped\n    ports:\n      - \"8080:8080\"\n    environment:\n      - AWS_REGION=\${AWS_REGION}\n      - S3_BUCKET_NAME=\${S3_BUCKET_NAME}\n    volumes:\n      - /opt/cadetex-backend/config:/app/config:ro\n      - /opt/cadetex-backend/logs:/app/logs\n" > /opt/cadetex-backend/docker-compose.prod.yml'
            
            # Crear .env para docker compose
            echo "ECR_IMAGE=${{ vars.ECR_REPOSITORY_URI }}:${{ github.sha }}" | sudo tee /opt/cadetex-backend/.env > /dev/null
            echo "AWS_REGION=${{ vars.AWS_REGION || 'sa-east-1' }}" | sudo tee -a /opt/cadetex-backend/.env > /dev/null
            echo "S3_BUCKET_NAME=${{ vars.S3_BUCKET_NAME }}" | sudo tee -a /opt/cadetex-backend/.env > /dev/null
            
            cd /opt/cadetex-backend
            # Parar/limpiar contenedor previo y liberar puerto 8080 si está en uso
            $DOCKER_CMD compose -f docker-compose.prod.yml down --remove-orphans || true
            $DOCKER_CMD stop cadetex-backend || true
            $DOCKER_CMD rm -f cadetex-backend || true
            sudo fuser -k 8080/tcp || true

            # Exportar variables necesarias para generar application.conf y para docker compose
            export RDS_ENDPOINT="${{ vars.RDS_ENDPOINT }}"
            export DB_NAME="${{ vars.DB_NAME || 'kdt' }}"
            export DB_USER="${{ vars.DB_USER || 'postgres' }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD || '' }}"

            # Log de diagnóstico (sin revelar password)
            echo "RDS_ENDPOINT len: ${#RDS_ENDPOINT}"
            echo "DB_NAME: ${DB_NAME:-<empty>}"
            echo "DB_USER: ${DB_USER:-<empty>}"

            # Fallback: obtener endpoint desde CloudFormation si no vino por variables
            if [ -z "$RDS_ENDPOINT" ]; then
              echo "RDS_ENDPOINT vacío. Consultando CloudFormation outputs..."
              RDS_ENDPOINT=$(aws cloudformation describe-stacks \
                --stack-name kdt-stack-prod \
                --query "Stacks[0].Outputs[?OutputKey=='RdsEndpoint'].OutputValue" \
                --output text \
                --region ${AWS_REGION:-sa-east-1} || true)
              echo "RDS_ENDPOINT (CFN) len: ${#RDS_ENDPOINT}"
            fi

            # Generar application.conf si no existe usando variables del pipeline (sin heredoc)
            sudo mkdir -p /opt/cadetex-backend/config
            if [ ! -f /opt/cadetex-backend/config/application.conf ]; then
              echo "Creando /opt/cadetex-backend/config/application.conf desde variables del pipeline"
              sudo bash -c 'printf "ktor {\n  development = false\n  deployment { port = 8080 }\n  application { modules = [ com.cadetex.ApplicationKt.module ] }\n}\n\n database {\n  host = \"${RDS_ENDPOINT}\"\n  port = 5432\n  name = \"${DB_NAME}\"\n  user = \"${DB_USER}\"\n  password = \"${DB_PASSWORD}\"\n  maxPoolSize = 10\n}\n" > /opt/cadetex-backend/config/application.conf'
            fi

            # Validar config
            sudo head -n 20 /opt/cadetex-backend/config/application.conf || true

            $DOCKER_CMD compose -f docker-compose.prod.yml pull
            $DOCKER_CMD compose -f docker-compose.prod.yml up -d
            
            echo "Esperando 5 segundos para que el contenedor inicie..."
            sleep 5
            $DOCKER_CMD compose -f docker-compose.prod.yml ps
            $DOCKER_CMD logs --tail 50 cadetex-backend || true
