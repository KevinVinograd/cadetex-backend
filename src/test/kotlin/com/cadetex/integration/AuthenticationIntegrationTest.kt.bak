package com.cadetex.integration

import com.cadetex.auth.JwtService
import com.cadetex.database.tables.*
import com.cadetex.module
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.server.testing.*
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.SchemaUtils
import org.jetbrains.exposed.sql.transactions.transaction
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.Assertions.*
import org.testcontainers.junit.jupiter.Container
import org.testcontainers.junit.jupiter.Testcontainers
import java.util.*

@Testcontainers
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class AuthenticationIntegrationTest {
    
    companion object {
        @Container
        val postgresContainer = KPostgreSQLContainer("postgres:15-alpine").apply {
            withDatabaseName("cadetex_auth_test")
            withUsername("cadetex_user")
            withPassword("cadetex_password")
        }
        
        lateinit var testDatabase: Database
        lateinit var jwtService: JwtService
        
        @BeforeAll
        @JvmStatic
        fun setup() {
            println("üöÄ Configurando test de autenticaci√≥n...")
            
            // Configurar base de datos de test
            testDatabase = Database.connect(
                url = postgresContainer.jdbcUrl,
                driver = "org.postgresql.Driver",
                user = postgresContainer.username,
                password = postgresContainer.password
            )
            
            // Crear tablas
            transaction(testDatabase) {
                SchemaUtils.create(
                    Organizations,
                    Users,
                    Clients,
                    Providers,
                    Couriers,
                    Tasks,
                    TaskPhotos,
                    TaskHistory
                )
            }
            
            jwtService = JwtService()
            println("‚úÖ Configuraci√≥n de autenticaci√≥n completada")
        }
        
        @AfterAll
        @JvmStatic
        fun cleanup() {
            println("üßπ Limpiando test de autenticaci√≥n...")
        }
    }
    
    @Test
    fun `test JWT token generation and validation`() {
        val user = com.cadetex.model.User(
            id = "test-user-123",
            organizationId = "test-org-456",
            name = "Test User",
            email = "test@example.com",
            passwordHash = "hashed-password",
            role = com.cadetex.model.UserRole.ORGADMIN
        )
        
        // Generar token
        val token = jwtService.generateToken(user)
        assertNotNull(token)
        assertTrue(token.isNotEmpty())
        println("‚úÖ Token JWT generado: ${token.take(20)}...")
        
        // Validar token
        val tokenData = jwtService.validateToken(token)
        assertNotNull(tokenData)
        assertEquals("test-user-123", tokenData?.userId)
        assertEquals("test@example.com", tokenData?.email)
        assertEquals("ORGADMIN", tokenData?.role)
        assertEquals("test-org-456", tokenData?.organizationId)
        
        println("‚úÖ Validaci√≥n de token JWT exitosa")
    }
    
    @Test
    fun `test login endpoint exists`() = testApplication {
        application {
            module()
        }
        
        // Test que el endpoint de login existe y responde
        val response = client.post("/auth/login") {
            contentType(ContentType.Application.Json)
            setBody("""{"email": "test@example.com", "password": "password123"}""")
        }
        
        // Deber√≠a responder (puede ser 200, 401, 404, etc.)
        assertTrue(response.status.value in 200..499, "Endpoint de login deber√≠a responder")
        
        println("‚úÖ Endpoint de login responde correctamente")
    }
    
    @Test
    fun `test login with invalid credentials`() = testApplication {
        application {
            module()
        }
        
        // Test login con credenciales inv√°lidas
        val response = client.post("/auth/login") {
            contentType(ContentType.Application.Json)
            setBody("""{"email": "invalid@example.com", "password": "wrongpassword"}""")
        }
        
        // Deber√≠a responder con error
        assertTrue(response.status.value in 400..499, "Login con credenciales inv√°lidas deber√≠a fallar")
        
        println("‚úÖ Login con credenciales inv√°lidas rechazado correctamente")
    }
    
    @Test
    fun `test protected endpoints require valid JWT`() = testApplication {
        application {
            module()
        }
        
        // Test sin token
        val responseWithoutToken = client.get("/users")
        assertEquals(HttpStatusCode.Unauthorized, responseWithoutToken.status)
        
        // Test con token inv√°lido
        val responseWithInvalidToken = client.get("/users") {
            header(HttpHeaders.Authorization, "Bearer invalid-token")
        }
        assertEquals(HttpStatusCode.Unauthorized, responseWithInvalidToken.status)
        
        println("‚úÖ Endpoints protegidos requieren JWT v√°lido")
    }
    
    @Test
    fun `test protected endpoints with valid JWT`() = testApplication {
        application {
            module()
        }
        
        // Generar token v√°lido
        val user = com.cadetex.model.User(
            id = "test-user-123",
            organizationId = "test-org-456",
            name = "Test User",
            email = "test@example.com",
            passwordHash = "hashed-password",
            role = com.cadetex.model.UserRole.ORGADMIN
        )
        
        val token = jwtService.generateToken(user)
        
        // Test con token v√°lido
        val response = client.get("/users") {
            header(HttpHeaders.Authorization, "Bearer $token")
        }
        
        // Deber√≠a responder (puede ser 200 o 404 dependiendo de la implementaci√≥n)
        assertTrue(response.status.value in 200..499, "Endpoint con token v√°lido deber√≠a responder")
        
        println("‚úÖ Endpoint con JWT v√°lido responde correctamente")
    }
    
    @Test
    fun `test different user roles have different access`() {
        val adminUser = com.cadetex.model.User(
            id = "admin-123",
            organizationId = "org-456",
            name = "Admin User",
            email = "admin@example.com",
            passwordHash = "hashed-password",
            role = com.cadetex.model.UserRole.ORGADMIN
        )
        
        val courierUser = com.cadetex.model.User(
            id = "courier-123",
            organizationId = "org-456",
            name = "Courier User",
            email = "courier@example.com",
            passwordHash = "hashed-password",
            role = com.cadetex.model.UserRole.COURIER
        )
        
        val adminToken = jwtService.generateToken(adminUser)
        val courierToken = jwtService.generateToken(courierUser)
        
        // Verificar que los tokens contienen los roles correctos
        val adminTokenData = jwtService.validateToken(adminToken)
        val courierTokenData = jwtService.validateToken(courierToken)
        
        assertEquals("ORGADMIN", adminTokenData?.role)
        assertEquals("COURIER", courierTokenData?.role)
        
        println("‚úÖ Diferentes roles de usuario generan tokens con roles correctos")
    }
}
